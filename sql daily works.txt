17.07.2023
--------------
DROP TABLE CUSTOMER;

CREATE TABLE CUSTOMER(
V_CUS_NAME VARCHAR2(100) CONSTRAINT V_CUS_NAME_NN NOT NULL,
    V_CUS_ADDRESS VARCHAR2(200) NOT NULL, 
    V_AADHAR_NO VARCHAR2(12), 
    V_EMAIL_ID VARCHAR2(100),
    V_MOBILENO VARCHAR2(10) NOT NULL,
    D_DOB DATE
    );

ALTER TABLE CUSTOMER
    ADD CONSTRAINT V_AADHAR_NO_PK
    PRIMARY KEY(V_AADHAR_NO);

ALTER TABLE CUSTOMER
    ADD CONSTRAINT V_MOBILENO_CK
    CHECK(LENGTH(V_MOBILENO)=10);

CREATE TABLE BANK(
    NAME VARCHAR2(100),
    ADDRESS VARCHAR2(200),
    IFSC VARCHAR2(11),
    ACCOUNT_TYPE VARCHAR2(30),
    AVAIL_BAL NUMBER(10,2),
    CARD_TYPE VARCHAR2(30),
    CARDNO NUMBER(16),
    CVV NUMBER(3)
);


CREATE TABLE ATM(
  ATM_ID VARCHAR2(50),
    ATM_NAME VARCHAR2(50),
    ATM_LOC VARCHAR2(100)
);

DDL AND DML:
--------------------

DROP TABLE DILIP;

CREATE TABLE DILIP(
    NAME VARCHAR2(50),
    AGE VARCHAR2(3),
    ADDRESS VARCHAR2(200),
    MOBILENO VARCHAR2(10)
);

'''ALTER TABLE DILIP ADD CONSTRAINT V_NAME PRIMARY KEY(NAME);

ALTER TABLE DILIP ADD GENDER VARCHAR2(10);

SELECT * FROM DILIP;

DESC DILIP;

INSERT INTO TABLE DILIP(NAME,AGE,ADDRESS,MOBILENO,GENDER) VALUES ('DILIP','23','ATHIPALAYAM,COIMBATORE','8973172512','MALE');'''


ALTER TABLE DILIP ADD CONSTRAINT MOBILENO UNIQUE (MOBILENO);

SELECT * FROM DILIP;

INSERT INTO DILIP(NAME,AGE,ADDRESS,MOBILENO) VALUES ('DILIP','23','COIMBATORE','8973172512');

INSERT INTO DILIP(NAME,AGE,ADDRESS,MOBILENO) VALUES ('ASWIN','25','COIMBATORE','9842292789');

INSERT INTO DILIP(NAME,AGE,ADDRESS,MOBILENO) VALUES ('BASKAR','47','HYDERABAD','9865042219');

SELECT * FROM TAB;

DESC DILIP;

SELECT * FROM DILIP 
WHERE AGE = 47;

ALTER TABLE DILIP MODIFY MOBILENO VARCHAR2(10);

SELECT * FROM DILIP;

ALTER TABLE DILIP ADD GENDER VARCHAR2(10);

ALTER TABLE DILIP DROP COLUMN GENDER;

ALTER TABLE DILIP RENAME COLUMN MOBILENO TO PH_NO;

SELECT * FROM DILIP;

ALTER TABLE DILIP MODIFY PH_NO VARCHAR2(10);


DELETE FROM DILIP
WHERE NAME = 'ASWIN';

ALTER TABLE DILIP ADD CONSTRAINT MOBILENO CHECK(LENGTH(PH_NO)=10);

SELECT * FROM DILIP;


UPDATE DILIP SET AGE=25 WHERE NAME='ASWIN' ;

INSERT INTO  DILIP(NAME) VALUES ('ASWIN');


UPDATE DILIP SET AGE=23 WHERE NAME='DILIP';

UPDATE DILIP SET (ADDRESS='KARAMADAI',PH_NO='994223386',GENDER='MALE') WHERE NAME = 'ASWIN';

COMMIT;

SELECT * FROM DILIP;

ALTER TABLE DILIP ADD CONSTRAINT PH_NO CHECK(LENGTH(PH_NO)=10);

ALTER TABLE DILIP RENAME COLUMN PH_NO TO MOBILENO;

INSERT INTO DILIP(NAME,AGE,ADDRESS,MOBILENO) VALUES ('DILIP','23','COIMBATORE','897172512');

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
DROP TABLE EMP;

CREATE TABLE EMP(
    NAME VARCHAR2(50),
    AGE VARCHAR2(3),
    EMPID VARCHAR2(4),
    DEPTNO VARCHAR2(2),
    DESG VARCHAR2(50)
);

INSERT INTO EMP(NAME,AGE,EMPID,DEPTNO,DESG) VALUES ('DILIPKUMAR','23','1701','10','ANALYST');

ALTER TABLE EMP ADD CONSTRAINT EMPID PRIMARY KEY (EMPID);

DROP TABLE DEPT;

CREATE TABLE DEPT(
        EMPID VARCHAR2(4),
    DEPTNO VARCHAR2(2),
    LOC VARCHAR2(50)
);

ALTER TABLE DEPT ADD CONSTRAINT EMP_ID_FK FOREIGN KEY (EMPID) REFERENCES EMP(EMPID); -- ADD FOREIGN KEY USING ALTER COMMAND

INSERT INTO DEPT(EMPID,DEPTNO,LOC) VALUES ('1701','10','COIMBATORE');
INSERT INTO DEPT(EMPID,DEPTNO,LOC) VALUES ('02','20','KARUR');
INSERT INTO DEPT(EMPID,DEPTNO,LOC) VALUES ('01','30','TRICHY');
DESC DEPT;
DESC EMP;

DROP TABLE DEPT1;

CREATE TABLE DEPT1 AS SELECT * FROM DEPT; -- CREATE IN  A DUPLICATE TABLE SAME AS DEPT

SELECT * FROM DEPT1;

DESC DEPT1;

ALTER TABLE DEPT1 ADD COUNRTY VARCHAR2(50); -- ADD COLUMN USING ALTER COMMAND
 
ALTER TABLE DEPT1 MODIFY COUNRTY VARCHAR2(10); -- MODIFY THE COUNTRY COLUMN SIZE

ALTER TABLE DEPT1 RENAME COLUMN COUNRTY TO COUNTRY; -- RENAME THE COLUMN COUNRTY TO COUNTRY

ALTER TABLE DEPT1 DROP COLUMN COUNTRY; -- DROP A COLUMN COUNTRY 

ALTER TABLE DEPT DISABLE CONSTRAINT EMP_ID_FK; -- DISABLE THE CONSTRAINT USING ALTER COMMAND

ALTER  TABLE EMP DISABLE CONSTRAINT EMPID; -- DISABLE THE CONSTRAINT USING ALTER COMMAND

ALTER TABLE EMP ENABLE CONSTRAINT EMPID; -- ENABLE THE CONSTRAINT USING ALTER COMMAND

ALTER TABLE DEPT ENABLE CONSTRAINT EMP_ID_FK; -- ENABLE THE CONSTRAINT USING ALTER COMMAND

-- NOTE

/* ENABLE THE CONSTRAINTS FOR SINGLE TABLE WE CAN DO IT IN A FIRST STEP, BUT IN A FOREIGN KEY
   CONSTRAINT MEANS WE FIRST DISABLE THE PARENT TABLE , AFTER THAT WE DISABLE CHILD TABLE*/

--DROP 
/* WE USED DROP OPTION MEANS TABLE HAS BEEN DELETED(ENTIRE RECORDS WILL BE DELETED), STRUCTURE FO THE TABLE REMAINS THE SAME
WE CHECK THAT USING DESC COMMAND*/
DROP TABLE DEPT1;
DESC DEPT1;
SELECT * FROM TAB;
-- TRUNCATE 
/* WE USED TRUNCATE MEANS ENTRIRE TABLE AND ITS RECORDS WILL BE PERMANENTLY REMOVED FROM DATABASE*/
TRUNCATE TABLE DEPT1;


--SEQUNCE IN ORACLE

CREATE TABLE EMP(
    NAME VARCHAR2(50),
    AGE VARCHAR2(3),
    EMPID VARCHAR2(4),
    DEPTNO VARCHAR2(2),
    DESG VARCHAR2(50)
);


INSERT INTO EMP(NAME,AGE,EMPID,DEPTNO,DESG) VALUES ('DILIPKUMAR','23','1701','10','ANALYST');

INSERT INTO EMP(NAME,AGE,EMPID,DEPTNO,DESG) VALUES ('ASWIN','25','1702','10','TESTER');

INSERT INTO EMP(NAME,AGE,EMPID,DEPTNO,DESG) VALUES ('KESAV','26','1704','30','DATA SCIENTIST');

INSERT INTO EMP(NAME,AGE,EMPID,DEPTNO,DESG) VALUES ('HARIKRISHNAN','23','1705','30','DEVELOPER');


SELECT * FROM EMP;
DROP SEQUENCE AGE_SEQ;

CREATE SEQUENCE AGE_SEQ
START WITH     1
INCREMENT BY   2
MAXVALUE       50 
NOCACHE  
NOCYCLE;


INSERT INTO EMP(NAME,AGE,EMPID,DEPTNO,DESG) VALUES ('SEKAR',AGE_SEQ.NEXTVAL,'1708','10','TESTER');

SELECT * FROM EMP;

DELETE FROM EMP
WHERE NAME = 'SEKAR';

DROP TABLE DEPT;

CREATE TABLE DEPT(
    DEPTNO VARCHAR2(50),
    DEPTNAME VARCHAR2(50)
);

DROP SEQUENCE DEPTNO;

CREATE SEQUENCE DEPTNO
START WITH 1
INCREMENT BY 5
MAXVALUE 100
NOCACHE
NOCYCLE;

SELECT * FROM SEQUENCE DEPTNO;

INSERT INTO DEPT VALUES('5','MECH');
INSERT INTO DEPT VALUES('7','CIVIL');
INSERT INTO DEPT VALUES('3','ECE');

SELECT * FROM DEPT;

INSERT INTO DEPT VALUES(DEPTNO.NEXTVAL,'CS');
INSERT INTO DEPT VALUES(DEPTNO.NEXTVAL,'IT');
INSERT INTO DEPT VALUES(DEPTNO.NEXTVAL,'MBA');
INSERT INTO DEPT VALUES(DEPTNO.NEXTVAL,'M.COM');

SELECT * FROM DEPT;

INSERT INTO DEPT VALUES('23','MCA')
    
INSERT INTO DEPT VALUES('11','BCA');

DELETE FROM DEPT WHERE DEPTNAME = 'CS';

INSERT INTO DEPT VALUES('45','BE');

--------------------------------------------------------------------------------------------------------------------------------------------
20/07/2023
-------------

DROP TABLE DEPT;

CREATE TABLE DEPT(

    N_DEPT_NO NUMBER(6),

    V_DEPT_NAME VARCHAR2(50)

);



CREATE SEQUENCE N_DEPT_NO_SEQ  

 START WITH     1  

 INCREMENT BY   5  

 MAXVALUE       100  

 NOCACHE  

 NOCYCLE;



INSERT INTO DEPT (N_DEPT_NO, V_DEPT_NAME)

VALUES (N_DEPT_NO_SEQ.NEXTVAL, 'QUALITY ENGINEERING');

INSERT INTO DEPT (N_DEPT_NO, V_DEPT_NAME)

VALUES (N_DEPT_NO_SEQ.NEXTVAL, 'ACCOUNTING');

INSERT INTO DEPT (N_DEPT_NO, V_DEPT_NAME)

VALUES (N_DEPT_NO_SEQ.NEXTVAL, 'DEVELOPMENT');

INSERT INTO DEPT (N_DEPT_NO, V_DEPT_NAME)

VALUES (N_DEPT_NO_SEQ.NEXTVAL, 'AUTOMATION');

INSERT INTO DEPT (N_DEPT_NO, V_DEPT_NAME)

VALUES (N_DEPT_NO_SEQ.NEXTVAL, 'ADMIN');



SELECT * FROM DEPT;



SELECT N_DEPT_NO_SEQ.NEXTVAL FROM DUAL;




------------------------------------------------------------------------------------------------------------------------

DATA DICTIONARY
----------------------------

CREATE TABLE STUD(
    NAME VARCHAR2(25) NOT NULL,
    AGE VARCHAR2(2) NOT NULL
);


RENAME STUD TO STUDENT;

INSERT INTO STUDENT(NAME,AGE) VALUES ('DILIPKUMAR','23');
INSERT INTO STUDENT(NAME,AGE) VALUES ('DINESH','22');
INSERT INTO STUDENT(NAME,AGE) VALUES ('SEENIVASAN','21');
INSERT INTO STUDENT(NAME,AGE) VALUES ('KESAV','23');
INSERT INTO STUDENT(NAME,AGE) VALUES ('ASWIN','25');

SELECT * FROM STUDENT;

-- VIEW THE CONSTRANT_NAME,TYPE IN A STUD TABLE (DATA DICTIONARY)
SELECT CONSTRAINT_NAME,CONSTRAINT_TYPE 
    FROM USER_CONSTRAINTS 
    WHERE TABLE_NAME = 'STUD';

-- RESULT
/*CONSTRAINT_NAME	CONSTRAINT_TYPE
SYS_C00128567940	C
SYS_C00128567941	C */

-- DELEETE A PARTICULAR COLUMN USING WHERE CLAUSE

DELETE FROM STUDENT WHERE NAME = 'ASWIN';

/*DATA DICTIONARY

Whenever we are installing oracle s/w internally oracle server is creating some pre-define tables are called “DATA DICTIONARIES”. 
These data dictionaries are used to store the information about database objects such as Tables, Indexes, Views, Synonyms, etc.

These data dictionaries are supporting the “SELECT” and “DESC” command only. So that data dictionaries are also called “READ ONLY TABLES” 
in the oracle database. If we want to view all data dictionaries in the oracle database then we need to use the following syntax*/
 
SELECT * FROM DICT;

SELECT  DISTINCT CONSTRAINT_TYPE
FROM USER_CONSTRAINTS;

/* RESULT  WILL BE 

Result Set 12
CONSTRAINT_TYPE
C
R
P
U */ 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

CREATE TABLE STUD(
    NAME VARCHAR2(25) NOT NULL,
    AGE VARCHAR2(2) NOT NULL
);

SELECT * FROM USER_CONS_COLUMNS; -- IT WAS SHOWING AN COULMN WISE USER CONTRAINTS ( DATA DICTIONARY)
/*
Result Set 1
OWNER	CONSTRAINT_NAME	TABLE_NAME	COLUMN_NAME	POSITION
SQL_QRTZWXZNKHPYABHQFFGCQMGNJ	SYS_C00128568519	STUD	NAME	 - 
SQL_QRTZWXZNKHPYABHQFFGCQMGNJ	SYS_C00128568520	STUD	AGE	 - 
*/

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-- FETCHING A SPECIFIC TYPE OF CONSTRAINT

SELECT * FROM USER_CONSTRAINTS
WHERE CONSTRAINT_TYPE='C';

INSERT INTO STUDENT(NAME,AGE) VALUES ('DILIPKUMAR','23');
INSERT INTO STUDENT(NAME,AGE) VALUES ('DINESH','22');
INSERT INTO STUDENT(NAME,AGE) VALUES ('SEENIVASAN','21');
INSERT INTO STUDENT(NAME,AGE) VALUES ('KESAV','23');
INSERT INTO STUDENT(NAME,AGE) VALUES ('ASWIN','25');

-- IT WILL GIVES THE NUMBER OF ROWS IN  A TABLE

SELECT COUNT(*) NOOFROWS FROM STUDENT;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/* INDEX IN SQL*/
-------------------------
/*SQL, an index is a database object that enhances the performance of data retrieval operations on a table. 
It acts like a data structure, providing a faster way to locate specific rows based on the values in indexed columns.
By using indexes, the database engine can avoid full table scans and quickly find the desired data
Here are some key points about indexes in SQL:

Purpose: The primary purpose of an index is to improve the speed of query execution by reducing the time it takes to find and retrieve data.

Structure: An index consists of a set of keys (usually columns) and pointers to the actual data rows. The keys are sorted in a way that
allows for efficient searching and access.

Types of Indexes: SQL databases offer different types of indexes. The two most common types are:

Clustered Index: Determines the physical order of data rows in the table based on the indexed column(s). Each table can have only one clustered index.
Non-Clustered Index: Creates a separate structure that maps keys to the corresponding data rows. A table can have multiple non-clustered indexes.
Creating Indexes: You can create indexes on one or more columns of a table using the CREATE INDEX statement.
The specific syntax for creating indexes may vary depending on the database system you are using.*/


DROP TABLE STUDENT;

CREATE TABLE STUDENT(
    NAME VARCHAR2(50),
	ID  NUMBER(3)
);

SELECT INDEX_NAME,INDEX_TYPE
FROM USER_INDEXES
WHERE TABLE_NAME = 'STUDENT';

DROP INDEX ID_INDEX;

CREATE INDEX ID_INDEX ON STUDENT(ID);

INSERT INTO STUDENT (NAME) VALUES ('DILIPKUMAR') ;

UPDATE STUDENT SET ID = 101 WHERE NAME = 'DILIPKUMAR';

SELECT * FROM STUDENT;

INSERT INTO STUDENT (NAME,ID) VALUES ('KRISHNA','102');
INSERT INTO STUDENT (NAME,ID) VALUES ('HARIKRISHNAN',103);
INSERT INTO STUDENT (NAME,ID) VALUES ('DARAN','105');

SELECT * FROM STUDENT WHERE ID = 102;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DISTINCT CLAUSE
----------------------------
SELECT MIN(SALARY)
FROM HR.EMPLOYEES;

-- DISTINCT CLAUSE
--IT IS USED TO REMOVE THE DUPLICATE RECORDS, IT EXECUTES ROW BY ROW

SELECT DISTINCT(DEPARTMENT_ID)
FROM HR.EMPLOYEES;

SELECT DISTINCT(COUNT(DEPARTMENT_ID))
FROM HR.EMPLOYEES;

SELECT DISTINCT(MAX(DEPARTMENT_ID))
FROM HR.EMPLOYEES;

SELECT DISTINCT(MIN(DEPARTMENT_ID)) AS "MIN_DEPT"
FROM HR.EMPLOYEES;

-- CHARACTER FUNCTIONS

-- LOWER

SELECT LOWER('DILIPKUMAR') AS LOWER
FROM DUAL;

-- UPPER

SELECT UPPER(q'['kerala is a god's blessed country]') AS UPPER
FROM DUAL;

-- INITCAP 
-- CAPITALAIZED EACH WORD OF THE FIRST CHARACHER


SELECT INITCAP(q'['kerala is a god's blessed country]') AS INITCAP
FROM DUAL;

SELECT INITCAP('hi dilip,when you reached your home?') AS INITCAP
FROM DUAL;

SELECT CONCAT('DILIP',' KUMAR') AS "CONCAT"
FROM DUAL;

SELECT CONCAT(FIRST_NAME,LAST_NAME) AS "FULL NAME"
FROM HR.EMPLOYEES;

-- LENGTH

SELECT LENGTH('DILIP KUMAR') AS "LENGTH OF STR"
FROM DUAL;

SELECT FIRST_NAME,LENGTH(FIRST_NAME) AS "FULL_NAME"
FROM HR.EMPLOYEES;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

25/07/2023
------------

SELECT * FROM  HR.EMPLOYEES;

-- SUBSTR
--extracts a substring from a string.
SELECT SUBSTR('India Post is a government-operated postal system in India',1,3) AS "SUB_STR"
FROM  DUAL;


SELECT SUBSTR('India Post is a government-operated postal system in India',1,20) AS "SUB_STR"
FROM  DUAL;
	
--INSTR
-- The INSTR function returns the position of a substring in a string.

SELECT INSTR('India Post is a government-operated postal system in India','In',2) AS "INSTR"
FROM DUAL; 

SELECT LPAD('SALARY',10,'*') AS "LPAD"
FROM DUAL;

SELECT RPAD('SALARY IS CRDITED',30,'₹') "RPAD"
FROM DUAL;

SELECT LPAD(RPAD('SALARY IS CREDITED',25,'*'),32,'*') FROM DUAL;

-- TRIM 
--The TRIM function removes specified characters from the beginning or end of a string.

SELECT TRIM('X' FROM 'XXXXXIndia Post is a government-operated postal system in IndiaXXXXX')
FROM DUAL;

-- NUMBER FUNCTIONS
---------------------------------------

SELECT ROUND(26.36) FROM DUAL;
SELECT ROUND(26.69) FROM DUAL;
SELECT ROUND(26.96) FROM DUAL;
SELECT ROUND(26.564) FROM DUAL;
SELECT ROUND(26.4999) FROM DUAL;

SELECT TRUNC(26.548548,2) FROM DUAL;
SELECT TRUNC(26.548548,3) FROM DUAL;
SELECT TRUNC(26.548548,1) FROM DUAL;

SELECT MOD(17,9) FROM DUAL;
SELECT MOD(25,5) FROM DUAL;
SELECT MOD(25,3) FROM DUAL;


SELECT POWER(2,5) FROM DUAL;
SELECT SQRT(16) FROM DUAL;

DATE AND TIME FUNCTIONS
-------------------------------------------

SELECT CURRENT_DATE AS "DATE" FROM DUAL; /* TO GIVE CURRENT SYSTEM TIME*/

SELECT CURRENT_TIMESTAMP FROM DUAL;/* TO GIVE REGION BASED TIME */

SELECT LAST_NAME,(SYSDATE-HIRE_DATE)/7 AS "WEEK" 
FROM HR.EMPLOYEES
WHERE DEPARTMENT_ID = 90;

SELECT SYSDATE AS CURRENT_DATE_TIME FROM DUAL;

-- ADD MONTHS

SELECT ADD_MONTHS('25-JUL-2023',2) FROM DUAL; 

SELECT ADD_MONTHS('25-JUL-2023',-6) FROM DUAL;

SELECT LAST_DAY(SYSDATE) FROM DUAL;

SELECT NEXT_DAY('25-FEB-2000','FRIDAY') FROM DUAL;

SELECT NEXT_DAY(SYSDATE,'SATURDAY') FROM DUAL;

SELECT NEXT_DAY(CURRENT_DATE+10,'SATURDAY') FROM DUAL;


SELECT MONTHS_BETWEEN(SYSDATE,'23-FEB-2025') FROM DUAL;

SELECT CURRENT_DATE,SESSIONTIMEZONE FROM DUAL; /* 

Result Set 11
CURRENT_DATE	SESSIONTIMEZONE
24-JUL-23	US/Pacific */

------------------------------------------------------------------------------------------------------------------------------

DROP TABLE EMP;

CREATE TABLE EMP
       (EMPNO NUMBER(4) NOT NULL,
        ENAME VARCHAR2(10),
        JOB VARCHAR2(9),
        MGR NUMBER(4),
        HIREDATE DATE,
        SAL NUMBER(7, 2),
        COMM NUMBER(7, 2),
        DEPTNO NUMBER(2));

INSERT INTO EMP VALUES
        (7902, 'FORD',   'ANALYST',   7566,
        TO_DATE('3-DEC-2022', 'DD-MON-YYYY'),  3000, NULL, 20);
INSERT INTO EMP VALUES
        (7934, 'MILLER', 'CLERK',     7782,
        TO_DATE('23-JAN-2023', 'DD-MON-YYYY'), 1300, NULL, 10);
INSERT INTO EMP VALUES
		(7845,'TOYO','SCIENTIST',7845,
    	TO_DATE('10-JUN-2023','DD-MON-YYYY'),3500,250,20)
INSERT INTO EMP VALUES
		(7845,'TOYO','SCIENTIST',7845,
    	'23-AUG-2022',3500,250,20)
INSERT INTO EMP VALUES
		(7845,'UNCLE','SCIENTIST',7845,
    	TO_DATE('30-JUN-1893','DD-MON-YYYY'),3785,2250,10)
INSERT INTO EMP VALUES
		(7845,'HARI','SOCIALIST',7845,
    	'15-AUG-2023',18000,2250,30);

------------------------------------------------------------------------------------------------------
SELECT * FROM EMP;

-- TO CHAR
--------------------------
SELECT TO_CHAR(HIREDATE) FROM EMP;

SELECT TO_CHAR(SYSDATE,'YYYY YY YEAR CC AD') FROM DUAL;

SELECT TO_CHAR(HIREDATE,'MMMONYYYY') FROM EMP;
SELECT TO_CHAR(HIREDATE,'MMMONYYYY') FROM EMP;
SELECT TO_CHAR(HIREDATE,'DAYMONYYYY') FROM EMP;

-- Example: Display employee on which day employees are joined.

SELECT ENAME || 'JOINED ON' || TO_CHAR(HIREDATE,'DAYMONYYYY') AS "JOINING DATE" FROM EMP;

SELECT * FROM EMP WHERE TO_CHAR(HIREDATE,'FMDAY')='FRIDAY';

--TO DATE()

SELECT TO_DATE(HIREDATE) FROM EMP;

SELECT TO_DATE(HIRE_DATE,'YYYY-MON-DD') FROM HR.EMPLOYEES;


SELECT TO_DATE(HIRE_DATE,'YYYY-MON-YYYY') FROM HR.EMPLOYEES;


SELECT EXTRACT(YEAR FROM SYSDATE)
FROM DUAL;

SELECT EXTRACT(YEAR FROM HIRE_DATE) AS year_value FROM HR.EMPLOYEES;

SELECT TO_CHAR(SALARY,'$90,0000.00')
FROM HR.EMPLOYEES
WHERE DEPARTMENT_ID = 20;

SELECT * FROM HR.EMPLOYEES;

SELECT TO_NUMBER('45845')
FROM DUAL;

SELECT FIRST_NAME,COMMISSION_PCT
FROM HR.EMPLOYEES;


SELECT FIRST_NAME,COMMISSION_PCT
FROM HR.EMPLOYEES;


SELECT FIRST_NAME,NVL(COMMISSION_PCT,25)
FROM HR.EMPLOYEES;


------------------------------------------------------------------------------------------------------------------------------------------------

NVL()
----------

IT IS USED TO FILL THE NULL VALUES

SYNTAX:
-------------
SELECT NVL(COLNAME, MESSAGE FOR NUL COL(SAME TYPE AS COL));

DROP TABLE EMP;

CREATE TABLE EMP(
    ENAME VARCHAR2(30),
    ID INT,
    HIREDATE DATE
);

INSERT INTO EMP(ENAME,ID,HIREDATE) VALUES ('DILIP',1704,'13-JUL-2023');

INSERT INTO EMP(ID,HIREDATE) VALUES (1706,'13-JUL-2023');

INSERT INTO EMP(ENAME,HIREDATE) VALUES ('SRUTHI NAIR','13-JUL-2023');


INSERT INTO EMP(ENAME,ID) VALUES ('KESAV',1709);

INSERT INTO EMP(ENAME,ID,HIREDATE) VALUES ('SEENIVASAN',1743,'13-JUL-2023');


SELECT * FROM EMP;

SELECT NVL(ENAME, 'NO INPUT GIVEN') FROM EMP;
SELECT NVL(ID, 0) FROM EMP;
SELECT NVL(HIREDATE,'01-JAN-2025') FROM EMP;


-------------------------------------------------------------------------------------------------------------------

NVL2()
----------
SAME AS NVL. INSTEAD OF FILLING THE NULL COLUMNS HERE WE USED 2 COL. IT TAKES LATEST ONE.

SYNTAX:
------------
SELECT NVL(COLNAME, MESSAGE FOR NUL COL(SAME TYPE AS COL));


SELECT NVL2(ENAME,ENAME,'NO NAME') FROM EMP;

SELECT NVL2(ID,ID,0) FROM EMP;

-----------------------------------------------------------------------------------------------------------------------
COALESEC()
------------------
The Oracle COALESCE() function accepts a list of arguments and returns the first one that evaluates to a non-null value.	

SELECT COALESCE(NULL,2)
FROM DUAL;


SELECT COALESCE(25,2)
FROM DUAL;


SELECT COALESCE(NULL,NULL,100)
FROM DUAL;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

DECODE()
----------------

The Oracle decode and case functions are used within the Oracle database to transform data values for one value to another. One of the most amazing features of the case the Oracle decode statements is that they allow us to create an index on data column values that do not exist in the database.

CREATE TABLE EMP(
    NAME VARCHAR2(50),
    AGE VARCHAR2(3),
    EMPID VARCHAR2(4),
    DEPTNO VARCHAR2(2),
    DESG VARCHAR2(50)
);

INSERT INTO EMP(NAME,AGE,EMPID,DEPTNO,DESG) VALUES ('DILIPKUMAR','23','1701','10','ANALYST');

INSERT INTO EMP(NAME,AGE,EMPID,DEPTNO,DESG) VALUES ('ASWIN','25','1702','10','TESTER');

INSERT INTO EMP(NAME,AGE,EMPID,DEPTNO,DESG) VALUES ('KESAV','26','1704','30','DATA SCIENTIST');

INSERT INTO EMP(NAME,AGE,EMPID,DEPTNO,DESG) VALUES ('HARIKRISHNAN','23','1705','30','DEVELOPER');

INSERT INTO EMP(NAME,AGE,EMPID,DEPTNO,DESG) VALUES ('SEENIVASAN','23','1743','20','DEVELOPER');

SELECT EMP.* FROM EMP;

SELECT EMP.*,
DECODE(DESG,'ANALYST','AN','TESTER','QE','DATA SCIENTIST','DSC','DEVELOPER','DV') AS "JOB_TYPE"
FROM EMP;

/* RESULT
NAME	AGE	EMPID	DEPTNO	DESG	JOB_TYPE
SEENIVASAN	23	1743	20	DEVELOPER	DV
DILIPKUMAR	23	1701	10	ANALYST	AN
ASWIN	25	1702	10	TESTER	QE
KESAV	26	1704	30	DATA SCIENTIST	DSC
HARIKRISHNAN	23	1705	30	DEVELOPER	DV
*/

---------------------------------------------------------------------------------------------------------------------------------------------------------



What is CASE Statement?

A CASE statement is similar to IF-THEN-ELSIF statement that selects one alternative based on the condition from the available options

SYNTAX:
--------------
CASE
   WHEN condition1 THEN result1
   WHEN condition2 THEN result2
   ...
   WHEN conditionN THEN resultN
   ELSE default_result
END


EXAMPLE:
----------------

SELECT * FROM
SCOTT.EMP;

SELECT EMP.*,
CASE 
WHEN SAL>1000 AND SAL<=3000 THEN 'AVERAGE SAL'
WHEN SAL>=3001 AND SAL<5000 THEN 'MEDIUM SAL'
WHEN SAL>=5000 THEN 'HIGH SAL'
ELSE 'LESS THAN AVERAGE SAL'
END AS "SAL COMPARISION"
FROM SCOTT.EMP;


RESULT:
----------
Result Set 5
EMPNO	ENAME	JOB	MGR	HIREDATE	SAL	COMM	DEPTNO	SAL COMPARISION
7839	KING	PRESIDENT	 - 	17-NOV-81	5000	 - 	10	HIGH SAL
7698	BLAKE	MANAGER	7839	01-MAY-81	2850	 - 	30	AVERAGE SAL
7782	CLARK	MANAGER	7839	09-JUN-81	2450	 - 	10	AVERAGE SAL
7566	JONES	MANAGER	7839	02-APR-81	2975	 - 	20	AVERAGE SAL
7788	SCOTT	ANALYST	7566	19-APR-87	3000	 - 	20	AVERAGE SAL
7902	FORD	ANALYST	7566	03-DEC-81	3000	 - 	20	AVERAGE SAL
7369	SMITH	CLERK	7902	17-DEC-80	800	 - 	20	LESS THAN AVERAGE SAL
7499	ALLEN	SALESMAN	7698	20-FEB-81	1600	300	30	AVERAGE SAL
7521	WARD	SALESMAN	7698	22-FEB-81	1250	500	30	AVERAGE SAL
7654	MARTIN	SALESMAN	7698	28-SEP-81	1250	1400	30	AVERAGE SAL
7844	TURNER	SALESMAN	7698	08-SEP-81	1500	0	30	AVERAGE SAL
7876	ADAMS	CLERK	7788	23-MAY-87	1100	 - 	20	AVERAGE SAL
7900	JAMES	CLERK	7698	03-DEC-81	950	 - 	30	LESS THAN AVERAGE SAL
7934	MILLER	CLERK	7782	23-JAN-82	1300	 - 	10	AVERAGE SAL

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



DROP TABLE EMP;

CREATE TABLE EMP(
    NAME VARCHAR2(50),
    AGE VARCHAR2(3),
    EMPID VARCHAR2(4),
    DEPTNO VARCHAR2(2),
    DESG VARCHAR2(50)
);

INSERT INTO EMP(NAME,AGE,EMPID,DEPTNO,DESG) VALUES ('DILIPKUMAR','23','1701','10','ANALYST');

ALTER TABLE EMP ADD CONSTRAINT EMPID PRIMARY KEY (EMPID);

DROP TABLE DEPT;

CREATE TABLE DEPT(
        EMPID VARCHAR2(4),
    DEPTNO VARCHAR2(2),
    LOC VARCHAR2(50)
);

ALTER TABLE DEPT ADD CONSTRAINT EMP_ID_FK FOREIGN KEY (EMPID) REFERENCES EMP(EMPID); -- ADD FOREIGN KEY USING ALTER COMMAND

INSERT INTO DEPT(EMPID,DEPTNO,LOC) VALUES ('1701','10','COIMBATORE');
INSERT INTO DEPT(EMPID,DEPTNO,LOC) VALUES ('02','20','KARUR');
INSERT INTO DEPT(EMPID,DEPTNO,LOC) VALUES ('01','30','TRICHY');
DESC DEPT;
DESC EMP;

DROP TABLE DEPT1;

CREATE TABLE DEPT1 AS SELECT * FROM DEPT; -- CREATE IN  A DUPLICATE TABLE SAME AS DEPT

SELECT * FROM DEPT1;

DESC DEPT1;

ALTER TABLE DEPT1 ADD COUNRTY VARCHAR2(50); -- ADD COLUMN USING ALTER COMMAND
 
ALTER TABLE DEPT1 MODIFY COUNRTY VARCHAR2(10); -- MODIFY THE COUNTRY COLUMN SIZE

ALTER TABLE DEPT1 RENAME COLUMN COUNRTY TO COUNTRY; -- RENAME THE COLUMN COUNRTY TO COUNTRY

ALTER TABLE DEPT1 DROP COLUMN COUNTRY; -- DROP A COLUMN COUNTRY 

ALTER TABLE DEPT DISABLE CONSTRAINT EMP_ID_FK; -- DISABLE THE CONSTRAINT USING ALTER COMMAND

ALTER  TABLE EMP DISABLE CONSTRAINT EMPID; -- DISABLE THE CONSTRAINT USING ALTER COMMAND

ALTER TABLE EMP ENABLE CONSTRAINT EMPID; -- ENABLE THE CONSTRAINT USING ALTER COMMAND

ALTER TABLE DEPT ENABLE CONSTRAINT EMP_ID_FK; -- ENABLE THE CONSTRAINT USING ALTER COMMAND

-- NOTE

/* ENABLE THE CONSTRAINTS FOR SINGLE TABLE WE CAN DO IT IN A FIRST STEP, BUT IN A FOREIGN KEY
   CONSTRAINT MEANS WE FIRST DISABLE THE PARENT TABLE , AFTER THAT WE DISABLE CHILD TABLE*/

--DROP 
/* WE USED DROP OPTION MEANS TABLE HAS BEEN DELETED(ENTIRE RECORDS WILL BE DELETED), STRUCTURE FO THE TABLE REMAINS THE SAME
WE CHECK THAT USING DESC COMMAND*/
DROP TABLE DEPT1;
DESC DEPT1;
SELECT * FROM TAB;
-- TRUNCATE 
/* WE USED TRUNCATE MEANS ENTRIRE TABLE AND ITS RECORDS WILL BE PERMANENTLY REMOVED FROM DATABASE*/
TRUNCATE TABLE DEPT1;


--SEQUNCE IN ORACLE

CREATE TABLE EMP(
    NAME VARCHAR2(50),
    AGE VARCHAR2(3),
    EMPID VARCHAR2(4),
    DEPTNO VARCHAR2(2),
    DESG VARCHAR2(50)
);


INSERT INTO EMP(NAME,AGE,EMPID,DEPTNO,DESG) VALUES ('DILIPKUMAR','23','1701','10','ANALYST');

INSERT INTO EMP(NAME,AGE,EMPID,DEPTNO,DESG) VALUES ('ASWIN','25','1702','10','TESTER');

INSERT INTO EMP(NAME,AGE,EMPID,DEPTNO,DESG) VALUES ('KESAV','26','1704','30','DATA SCIENTIST');

INSERT INTO EMP(NAME,AGE,EMPID,DEPTNO,DESG) VALUES ('HARIKRISHNAN','23','1705','30','DEVELOPER');


SELECT * FROM EMP;
DROP SEQUENCE AGE_SEQ;

CREATE SEQUENCE AGE_SEQ
START WITH     1
INCREMENT BY   2
MAXVALUE       50 
NOCACHE  
NOCYCLE;


INSERT INTO EMP(NAME,AGE,EMPID,DEPTNO,DESG) VALUES ('SEKAR',AGE_SEQ.NEXTVAL,'1708','10','TESTER');

SELECT * FROM EMP;

DELETE FROM EMP
WHERE NAME = 'SEKAR';

DROP TABLE DEPT;

CREATE TABLE DEPT(
    DEPTNO VARCHAR2(50),
    DEPTNAME VARCHAR2(50)
);

DROP SEQUENCE DEPTNO;

CREATE SEQUENCE DEPTNO
START WITH 1
INCREMENT BY 5
MAXVALUE 100
NOCACHE
NOCYCLE;

SELECT * FROM SEQUENCE DEPTNO;

INSERT INTO DEPT VALUES('5','MECH');
INSERT INTO DEPT VALUES('7','CIVIL');
INSERT INTO DEPT VALUES('3','ECE');

SELECT * FROM DEPT;

INSERT INTO DEPT VALUES(DEPTNO.NEXTVAL,'CS');
INSERT INTO DEPT VALUES(DEPTNO.NEXTVAL,'IT');
INSERT INTO DEPT VALUES(DEPTNO.NEXTVAL,'MBA');
INSERT INTO DEPT VALUES(DEPTNO.NEXTVAL,'M.COM');

SELECT * FROM DEPT;

INSERT INTO DEPT VALUES('23','MCA')
    
INSERT INTO DEPT VALUES('11','BCA');

DELETE FROM DEPT WHERE DEPTNAME = 'CS';

INSERT INTO DEPT VALUES('45','BE');

--------------------------------------------------------------------------------------------------------------------------------------------
20/07/2023
-------------

DROP TABLE DEPT;

CREATE TABLE DEPT(

    N_DEPT_NO NUMBER(6),

    V_DEPT_NAME VARCHAR2(50)

);



CREATE SEQUENCE N_DEPT_NO_SEQ  

 START WITH     1  

 INCREMENT BY   5  

 MAXVALUE       100  

 NOCACHE  

 NOCYCLE;



INSERT INTO DEPT (N_DEPT_NO, V_DEPT_NAME)

VALUES (N_DEPT_NO_SEQ.NEXTVAL, 'QUALITY ENGINEERING');

INSERT INTO DEPT (N_DEPT_NO, V_DEPT_NAME)

VALUES (N_DEPT_NO_SEQ.NEXTVAL, 'ACCOUNTING');

INSERT INTO DEPT (N_DEPT_NO, V_DEPT_NAME)

VALUES (N_DEPT_NO_SEQ.NEXTVAL, 'DEVELOPMENT');

INSERT INTO DEPT (N_DEPT_NO, V_DEPT_NAME)

VALUES (N_DEPT_NO_SEQ.NEXTVAL, 'AUTOMATION');

INSERT INTO DEPT (N_DEPT_NO, V_DEPT_NAME)

VALUES (N_DEPT_NO_SEQ.NEXTVAL, 'ADMIN');



SELECT * FROM DEPT;



SELECT N_DEPT_NO_SEQ.NEXTVAL FROM DUAL;




------------------------------------------------------------------------------------------------------------------------

DATA DICTIONARY
----------------------------

CREATE TABLE STUD(
    NAME VARCHAR2(25) NOT NULL,
    AGE VARCHAR2(2) NOT NULL
);


RENAME STUD TO STUDENT;

INSERT INTO STUDENT(NAME,AGE) VALUES ('DILIPKUMAR','23');
INSERT INTO STUDENT(NAME,AGE) VALUES ('DINESH','22');
INSERT INTO STUDENT(NAME,AGE) VALUES ('SEENIVASAN','21');
INSERT INTO STUDENT(NAME,AGE) VALUES ('KESAV','23');
INSERT INTO STUDENT(NAME,AGE) VALUES ('ASWIN','25');

SELECT * FROM STUDENT;

-- VIEW THE CONSTRANT_NAME,TYPE IN A STUD TABLE (DATA DICTIONARY)
SELECT CONSTRAINT_NAME,CONSTRAINT_TYPE 
    FROM USER_CONSTRAINTS 
    WHERE TABLE_NAME = 'STUD';

-- RESULT
/*CONSTRAINT_NAME	CONSTRAINT_TYPE
SYS_C00128567940	C
SYS_C00128567941	C */

-- DELEETE A PARTICULAR COLUMN USING WHERE CLAUSE

DELETE FROM STUDENT WHERE NAME = 'ASWIN';

/*DATA DICTIONARY

Whenever we are installing oracle s/w internally oracle server is creating some pre-define tables are called “DATA DICTIONARIES”. 
These data dictionaries are used to store the information about database objects such as Tables, Indexes, Views, Synonyms, etc.

These data dictionaries are supporting the “SELECT” and “DESC” command only. So that data dictionaries are also called “READ ONLY TABLES” 
in the oracle database. If we want to view all data dictionaries in the oracle database then we need to use the following syntax*/
 
SELECT * FROM DICT;

SELECT  DISTINCT CONSTRAINT_TYPE
FROM USER_CONSTRAINTS;

/* RESULT  WILL BE 

Result Set 12
CONSTRAINT_TYPE
C
R
P
U */ 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

CREATE TABLE STUD(
    NAME VARCHAR2(25) NOT NULL,
    AGE VARCHAR2(2) NOT NULL
);

SELECT * FROM USER_CONS_COLUMNS; -- IT WAS SHOWING AN COULMN WISE USER CONTRAINTS ( DATA DICTIONARY)
/*
Result Set 1
OWNER	CONSTRAINT_NAME	TABLE_NAME	COLUMN_NAME	POSITION
SQL_QRTZWXZNKHPYABHQFFGCQMGNJ	SYS_C00128568519	STUD	NAME	 - 
SQL_QRTZWXZNKHPYABHQFFGCQMGNJ	SYS_C00128568520	STUD	AGE	 - 
*/

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-- FETCHING A SPECIFIC TYPE OF CONSTRAINT

SELECT * FROM USER_CONSTRAINTS
WHERE CONSTRAINT_TYPE='C';

INSERT INTO STUDENT(NAME,AGE) VALUES ('DILIPKUMAR','23');
INSERT INTO STUDENT(NAME,AGE) VALUES ('DINESH','22');
INSERT INTO STUDENT(NAME,AGE) VALUES ('SEENIVASAN','21');
INSERT INTO STUDENT(NAME,AGE) VALUES ('KESAV','23');
INSERT INTO STUDENT(NAME,AGE) VALUES ('ASWIN','25');

-- IT WILL GIVES THE NUMBER OF ROWS IN  A TABLE

SELECT COUNT(*) NOOFROWS FROM STUDENT;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/* INDEX IN SQL*/
-------------------------
/*SQL, an index is a database object that enhances the performance of data retrieval operations on a table. 
It acts like a data structure, providing a faster way to locate specific rows based on the values in indexed columns.
By using indexes, the database engine can avoid full table scans and quickly find the desired data
Here are some key points about indexes in SQL:

Purpose: The primary purpose of an index is to improve the speed of query execution by reducing the time it takes to find and retrieve data.

Structure: An index consists of a set of keys (usually columns) and pointers to the actual data rows. The keys are sorted in a way that
allows for efficient searching and access.

Types of Indexes: SQL databases offer different types of indexes. The two most common types are:

Clustered Index: Determines the physical order of data rows in the table based on the indexed column(s). Each table can have only one clustered index.
Non-Clustered Index: Creates a separate structure that maps keys to the corresponding data rows. A table can have multiple non-clustered indexes.
Creating Indexes: You can create indexes on one or more columns of a table using the CREATE INDEX statement.
The specific syntax for creating indexes may vary depending on the database system you are using.*/


DROP TABLE STUDENT;

CREATE TABLE STUDENT(
    NAME VARCHAR2(50),
	ID  NUMBER(3)
);

SELECT INDEX_NAME,INDEX_TYPE
FROM USER_INDEXES
WHERE TABLE_NAME = 'STUDENT';

DROP INDEX ID_INDEX;

CREATE INDEX ID_INDEX ON STUDENT(ID);

INSERT INTO STUDENT (NAME) VALUES ('DILIPKUMAR') ;

UPDATE STUDENT SET ID = 101 WHERE NAME = 'DILIPKUMAR';

SELECT * FROM STUDENT;

INSERT INTO STUDENT (NAME,ID) VALUES ('KRISHNA','102');
INSERT INTO STUDENT (NAME,ID) VALUES ('HARIKRISHNAN',103);
INSERT INTO STUDENT (NAME,ID) VALUES ('DARAN','105');

SELECT * FROM STUDENT WHERE ID = 102;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
26/07/2023
-------------


-- MERGE 
/*SQL, the MERGE statement is used to perform an "upsert" operation, which is a combination of an INSERT and an UPDATE operation. 
It allows you to conditionally insert or update data into a target table based on whether the matching 
rows exist in the source table or not. The MERGE statement is often used to synchronize data between two tables.

SYNTAX:
-------
MERGE INTO target_table USING source_table
ON (condition_to_match_rows)
WHEN MATCHED THEN
    UPDATE SET column1 = value1, column2 = value2, ...
WHEN NOT MATCHED THEN
    INSERT (column1, column2, ...)
    VALUES (value1, value2, ...);
*/

DROP TABLE EMPLOYEEID;

CREATE TABLE EMPLOYEEID(
    ID INT,
    FIRST_NAME VARCHAR2(50),
    LAST_NAME VARCHAR2(50),
	DEPT VARCHAR2(50),
    SAL NUMBER(5,2)
);


INSERT INTO EMPLOYEEID (ID,FIRST_NAME,LAST_NAME,DEPT,SAL) VALUES (11,'DILIPKUMAR','PITCHAIMUTHU','IT',800);
INSERT INTO EMPLOYEEID (ID,FIRST_NAME,LAST_NAME,DEPT,SAL) VALUES (12,'SEENIVASAN','SELVAMANI','MSW',700);
INSERT INTO EMPLOYEEID (ID,FIRST_NAME,LAST_NAME,DEPT,SAL) VALUES (13,'HARIKRISHNAN','HARIDASS','COMMERCE',600);
INSERT INTO EMPLOYEEID (ID,FIRST_NAME,LAST_NAME,DEPT,SAL) VALUES (14,'KESAV','VENUGOPAL','SOCIAL DEVELOPMENT',800);

DROP TABLE EMPLOYEEID_S;

CREATE TABLE EMPLOYEEID_S AS SELECT * FROM EMPLOYEEID;


INSERT INTO EMPLOYEEID_S (ID,FIRST_NAME,LAST_NAME,DEPT,SAL) VALUES (14,'KESAVAN','VENUGOPALAN','SOCIAL DEVELOPMENT',850);

INSERT INTO EMPLOYEEID_S (ID,FIRST_NAME,LAST_NAME,DEPT,SAL) VALUES (13,'HARIKRISHNA','HARIDASS KERALA','SOCIAL WORKER',750);

INSERT INTO EMPLOYEEID_S (ID,FIRST_NAME,LAST_NAME,DEPT,SAL) VALUES (18,'AMUTHA','KRISHNASAMY','AGRICULTURE AND FERTILIZER',750);


SELECT * FROM EMPLOYEEID;

SELECT * FROM EMPLOYEEID_S;

DELETE FROM EMPLOYEEID_S; -- IT IS FOR DELETING ALL RECORDS IN  A TABLE

MERGE INTO EMPLOYEEID E
USING   EMPLOYEEID_S E1
ON (E.ID = E1.ID)
WHEN MATCHED THEN
UPDATE SET 
    	E.FIRST_NAME=E1.FIRST_NAME,
    	E.LAST_NAME = E1.LAST_NAME,
    	E.DEPT = E1.DEPT,
    	E.SAL = E1.SAL    
WHEN NOT MATCHED THEN 
		INSERT (ID,FIRST_NAME,LAST_NAME,DEPT,SAL) VALUES (E1.ID,E1.FIRST_NAME,E1.LAST_NAME,E1.DEPT,E1.SAL)

SELECT * FROM EMPLOYEEID;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-- UNUSED OPTION--
------------------------------
YOU USE TO SET UNUSED OPTION TO MARK ONE OR MORE COLUMN AS UNUSED.
DROP TABLE EMP;

CREATE TABLE EMP(
    ID INT,
    FIRST_NAME VARCHAR2(50),
    LAST_NAME VARCHAR2(50),
	DEPT VARCHAR2(50),
    SAL NUMBER(5,2),
    LOC VARCHAR2(50)
);


INSERT INTO EMP (ID,FIRST_NAME,LAST_NAME,DEPT,SAL) VALUES (11,'DILIPKUMAR','PITCHAIMUTHU','IT',800);
INSERT INTO EMP (ID,FIRST_NAME,LAST_NAME,DEPT,SAL) VALUES (12,'SEENIVASAN','SELVAMANI','MSW',700);
INSERT INTO EMP (ID,FIRST_NAME,LAST_NAME,DEPT,SAL) VALUES (13,'HARIKRISHNAN','HARIDASS','COMMERCE',600);
INSERT INTO EMP (ID,FIRST_NAME,LAST_NAME,DEPT,SAL) VALUES (14,'KESAV','VENUGOPAL','SOCIAL DEVELOPMENT',800);

SELECT * FROM EMP;

ALTER TABLE EMP
SET UNUSED COLUMN LOC;

SELECT * FROM EMP;

ALTER TABLE EMP
SET UNUSED COLUMN ID ;

SELECT * FROM EMP;

SELECT * FROM EMP
WHERE ID = 11;

--------------------------------------------------------------------------------------------------------------------------------------------------

COMMENT CREATION FOR TABLES
---------------------------------------------------

DROP TABLE EMP;

CREATE TABLE EMP(
    ID INT,
    FIRST_NAME VARCHAR2(50),
    LAST_NAME VARCHAR2(50),
	DEPT VARCHAR2(50),
    SAL NUMBER(5,2),
    LOC VARCHAR2(50)
);

COMMENT ON TABLE EMP 
IS ' EMPLOYESS INFORMATION'; -- CREATING COMMENT FOR TABLE
 
SELECT * FROM USER_TAB_COMMENTS; -- TO VIEW THE COMMENT FOR USER CREATED TABLES

COMMENT ON  COLUMN EMP.SAL
IS 'SALARY INFORMATION FOR ALL EMPLOYEES'; -- CREATING COMMENT FOR COLUMNS

SELECT * FROM USER_COL_COMMENTS;  -- TO VIEW THE COMMENT FOR USER CREATED COLUMNS

SELECT * FROM ALL_TAB_COMMENTS;

SELECT * FROM ALL_COL_COMMENTS;



---------------------------------------------------------------------------------------------------------------------------

ENABLING AND DISABLING AND DROPPING A  CONSTRAINT
-----------------------------------------------------------------------------------------



DROP TABLE DEPTID;

CREATE TABLE DEPTID(
    ID  INT,
    DEPT VARCHAR2(50),
    LOC  VARCHAR2(50)
);

ALTER TABLE DEPTID ADD CONSTRAINTS DEPTID_FK FOREIGN KEY (ID) REFERENCES EMPLOYEEID(ID);


ALTER TABLE DEPTID ENABLE CONSTRAINT DEPTID_FK ;

ALTER TABLE DEPTID DISABLE CONSTRAINT DEPTID_FK;

   ALTER TABLE DEPTID DROP CONSTRAINTS DEPTID_FK;

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

CASCADING CONSTRAINT:
-----------------------------------
DROP TABLE EMPLOYEEID;
CREATE TABLE EMPLOYEEID(
    ID INT,
    FIRST_NAME VARCHAR2(50),
    LAST_NAME VARCHAR2(50),
	DEPT VARCHAR2(50),
    SAL NUMBER(5,2)
);
ALTER TABLE EMPLOYEEID ADD CONSTRAINTS EMPLOYEEID_PK PRIMARY KEY(ID);

INSERT INTO EMPLOYEEID (ID,FIRST_NAME,LAST_NAME,DEPT,SAL) VALUES (11,'DILIPKUMAR','PITCHAIMUTHU','IT',800);
INSERT INTO EMPLOYEEID (ID,FIRST_NAME,LAST_NAME,DEPT,SAL) VALUES (12,'SEENIVASAN','SELVAMANI','MSW',700);
INSERT INTO EMPLOYEEID (ID,FIRST_NAME,LAST_NAME,DEPT,SAL) VALUES (13,'HARIKRISHNAN','HARIDASS','COMMERCE',600);
INSERT INTO EMPLOYEEID (ID,FIRST_NAME,LAST_NAME,DEPT,SAL) VALUES (14,'KESAV','VENUGOPAL','SOCIAL DEVELOPMENT',800);
INSERT INTO EMPLOYEEID (ID,FIRST_NAME,LAST_NAME,DEPT,SAL) VALUES (15,'RAGUL GANDHI','RAJIV GANDHI','COGNRESS PARTY',100);



DROP TABLE DEPTID;
CREATE TABLE DEPTID(
    ID  INT,
    DEPT VARCHAR2(50),
    LOC  VARCHAR2(50)
);
ALTER TABLE DEPTID ADD CONSTRAINTS DEPTID_PK PRIMARY KEY(ID);
ALTER TABLE DEPTID ADD CONSTRAINTS DEPTID_FK FOREIGN KEY (ID) REFERENCES EMPLOYEEID(ID);

INSERT INTO DEPTID(ID,DEPT,LOC) VALUES(11,'IT','COIMBATORE');
INSERT INTO DEPTID(ID,DEPT,LOC) VALUES(12,'MSW','ERODE');
INSERT INTO DEPTID(ID,DEPT,LOC) VALUES(14,'SOCIAL DEVELOPMENT','COIMBATORE');

SELECT * FROM DEPTID;

DROP TABLE LOC;
CREATE TABLE LOC(
    LOC_NAME VARCHAR2(50),
    ID INT
);
ALTER TABLE LOC ADD CONSTRAINTS LOC_PK PRIMARY KEY (ID);
ALTER TABLE LOC ADD CONSTRAINTS LOK_FK FOREIGN KEY (ID) REFERENCES DEPTID(ID);

INSERT INTO LOC(LOC_NAME,ID) VALUES ('ATHIPALAYAM',11);
INSERT INTO LOC(LOC_NAME,ID) VALUES ('ATHIPALAYAM',14);


DELETE FROM EMPLOYEEID WHERE ID = 14;
DELETE FROM DEPTID WHERE ID = 14;
DELETE FROM LOC WHERE ID = 14;


SELECT * FROM LOC;
SELECT * FROM DEPTID;
SELECT * FROM EMPLOYEEID;
----------------------------------------------------------------------------------------------
 --cascading constraint in oracle sql
------------------------------------------------------------------------
/*In Oracle SQL, cascading constraints refer to the ability to define actions that are automatically applied to related records 
in child tables when certain actions are performed on the parent table's records. These actions typically involve DELETE and 
UPDATE operationson the parent table, and the cascading constraints specify how these changes should be propagated to the child tables.*/


----------------------------------------------------------------------------------------------------------------------------

--GROUP BY
-----------------------------------
--WAQTD NUMBER OF EMPLOYEES WORKING IN EACH DEPT EXCEPT PRESIDENT
SELECT * FROM SCOTT.EMP;

SELECT COUNT(*),DEPTNO
FROM SCOTT.EMP
WHERE JOB NOT IN 'PRESIDENT'
GROUP BY DEPTNO;

--WAQTD TOTAL SALARY NEEDED TO PAY ALL THE EMPLOYEES IN JOB

SELECT SUM(SAL) AS "TOTAL SAL",JOB
FROM SCOTT.EMP
GROUP BY JOB;

--WAQTD NUMBER OF EMPLOYEES WORKING AS MANAGER IN EACH DEPT

SELECT COUNT(*) AS "TOTAL NO OF MANAGERS",DEPTNO
FROM SCOTT.EMP
WHERE JOB IN ('MANAGER')
GROUP BY DEPTNO;

-- WAQTD AVG SALARY NEEDED TO PAY ALL THE EMPLOYEES IN EACH DEPT EXCLUDING THE EMPLOYEES OF DEPTNO 20

SELECT AVG(SAL),DEPT
FROM SCOTT.EMP
WHERE DEPTNO NOT IN 20
GROUP BY JOB;

-- WAQTD NUMBER OF EMPLOYEES HAVING CHARACTER 'A' IN THEIR NAMES IN EACH JOB
SELECT COUNT(*)
FROM SCOTT.EMP
WHERE ENAME LIKE '%A'
GROUP BY JOB;

--WAQTD NUMBER OF EMP AND AVERAGE SALARY NEEDED TO PAY THE EMPLOYEES WHOSE SAL IN GREATER THAN 2000 IN EACH DEPT

SELECT COUNT(*)
FROM SCOTT.EMP
WHERE SAL>2000
GROUP BY DEPT;

-- WAQTD TOTAL SAL NEEDED TO PAY AND NUMBER OF SALESMAN IN EACH DEPT
SELECT SUM(SAL),COUNT(*)
FROM SCOTT.EMP
WHERE JOB = 'SALESMAN'
GROUP BY JOB;

--WAQTD NUMER OF EMPLOYEES WITH THEIR MAX SALARY IN EACH JOB

SELECT COUNT(*),MAX(SAL),JOB
FROM SCOTT.EMP
GROUP BY JOB;

-- WAQTD MAXIMUM SALARIES GIVEN TO AN EMPLOYEE WORKING IN EACH DEPT

SELECT MAX(SAL),DEPTNO
FROM SCOTT.EMP
GROUP BY DEPTNO;

--WAQTD NUMBER OF TIMES THE SALARIES PRESENT IN THE TABLE IN EACH JOB

SELECT COUNT(SAL),JOB
FROM SCOTT.EMP
GROUP BY JOB;

--HAVING CLAUSE
-------------------------

--WAQTD DEPTNO AND NUMBER OF EMP WORKING IN EACH DEPT IF THERE ARE ATLEAST 2 CLERKS IN EACH DEPT

SELECT DEPTNO,COUNT(*)
FROM SCOTT.EMP
WHERE JOB = 'CLERK'
GROUP BY JOB
HAVING COUNT(*)>=2;

--WAQTD DEPTNO AND TOTAL SALARY NEEDED TO PAY ALL EMP IN EACH DEPT THERE ARE ATLEAST 4 RMP IN EACH DEPT

SELECT DEPTNO,SUM(SAL)
FROM SCOTT.EMP
GROUP BY DEPTNO
HAVING COUNT(*)>=4;

--3.WAQTD NUMBER OF EMP EARNING SAL MORE THAN 1200 IN EACH JOB AND THE TOTAL SAL NEED TO PAY EMP OF EACH JOB MUST 
 -- EXCESS 3800

SELECT COUNT(*),JOB,SUM(SAL)
FROM SCOTT.EMP
WHERE SAL>1200 
GROUP BY JOB
HAVING SUM(SAL)>3800;

--4. WAQTD DEPTNO AND NO OF EMPLOYEES WORKING ONLY IF THERE ARE 2 EMPLOYEES ARE  WORKING AS MANAGER IN EACH DPARTMENT

SELECT DEPTNO,COUNT(*)
FROM SCOTT.EMP
WHERE JOB = 'MANAGER'
GROUP BY DEPTNO
HAVING COUNT(*)>=2;

--5.WAQTD JOB AND  MAX SAL  OF EMP IN EACH JOB AND MAX SAL EXCESS 2600

SELECT JOB,MAX(SAL)
FROM SCOTT.EMP
GROUP BY JOB
HAVING MAX(SAL)>2600;

--6.WAQTD SALARIES WHICH ARE REPEATED IN THE TABLE

SELECT COUNT(*),SAL
FROM SCOTT.EMP
GROUP BY SAL
HAVING COUNT(*)>1;

--7. WAQTD HIREDATE WHICH ARE DUPLICATED IN THE EMP TABLE

SELECT HIREDATE,COUNT(*)
FROM SCOTT.EMP
GROUP BY HIREDATE
HAVING COUNT(*)>1;

--8. WAQTD AVERAGE SALARY OF EACH DEPT IF AVERAGE SALARY IS LESS THAN 3000
SELECT ROUND(AVG(SAL)),DEPTNO
FROM SCOTT.EMP
GROUP BY DEPTNO
HAVING AVG(SAL)<3000;


--9. WRITE A QUERY TO DISPLAY, DEPTNO IF THERE ARE ATLEAST 3 EMP IN EACH DEPT WHOSE NAME HAS CHAR 'A' OR 'S';

SELECT DEPTNO
FROM SCOTT.EMP
WHERE ENAME LIKE '%A%' OR '%S%'
GROUP BY DEPTNO
HAVING COUNT(DISTINCT(ENAME))>=3;


--10.WAQTD MIN AND MAX SALARIES OF EACH JOB IF MIN SAL IS MORE THAN 1000 AND MAX SAL IS LESS THAN 5000.

SELECT MIN(SAL),MAX(SAL),JOB
FROM SCOTT.EMP
GROUP BY JOB
HAVING MIN(SAL) > 1000 AND MAX(SAL)<5000;






















